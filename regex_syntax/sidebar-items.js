initSidebarItems({"enum":[["ErrorKind","The specific type of parse error that can occur."],["Expr","A regular expression abstract syntax tree.An `Expr` represents the abstract syntax of a regular expression."],["Repeater","The type of a repeat operator expression."]],"fn":[["quote","Escapes all regular expression meta characters in `text`.The string returned may be safely used as a literal in a regular expression."]],"struct":[["CharClass","A character class.A character class has a canonical format that the parser guarantees. Its canonical format is defined by the following invariants:Given any Unicode scalar value, it is matched by *at most* one character range in a canonical character class. Every adjacent character range is separated by at least one Unicode scalar value. Given any pair of character ranges `r1` and `r2`, if `r1.end < r2.start`, then `r1` comes before `r2` in a canonical character class. In sum, any `CharClass` produced by this crate's parser is a sorted sequence of non-overlapping ranges. This makes it possible to test whether a character is matched by a class with a binary search.Additionally, a character class may be marked *case insensitive*. If it's case insensitive, then:Simple case folding has been applied to all ranges. Simple case folding must be applied to a character before testing whether it matches the character class."],["ClassRange","A single inclusive range in a character class.Since range boundaries are defined by Unicode scalar values, the boundaries can never be in the open interval `(0xD7FF, 0xE000)`. However, a range may *cover* codepoints that are not scalar values.Note that this has a few convenient impls on `PartialEq` and `PartialOrd` for testing whether a character is contained inside a given range."],["Error","A parse error.This includes details about the specific type of error and a rough approximation of where it occurred."]],"type":[["Result","An alias for computations that can return a `Error`."]]});